name: refresh

on:
  workflow_dispatch:
  schedule:
    - cron: '21 13 4,15,26 * *'
  # watch:
  #   types: [started]

jobs:
  auto-update:
    runs-on: ubuntu-latest
    permissions:
      # Read repository contents
      contents: write
       # Write/update Actions secrets (required for token persistence)
      actions: write

    steps:
      # Checkout repository to access source code
      - name: Checkout
        uses: actions/checkout@v3

      # Install .NET 10 SDK for C# script execution
      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '10.0.x'
          
      # Refresh OAuth2 refresh tokens for all configured accounts 
      # This mode:
      # - Exchanges current refresh tokens for new ones
      # - Encrypts and writes updated tokens back to GitHub Secrets (ACCOUNTS_JSON)
      # - Prevents token expiration that would break automated workflows
      - name: Refresh and Persist OAuth Tokens
        shell: bash
        env: 
          # Current repository identifier in 'owner/repo' format
          REPO:  ${{ github.repository }}    
          # Personal Access Token (PAT)
          PAT: ${{ secrets.PAT }}               
          # JSON configuration containing multiple Microsoft accounts
          # Format: [{"ClientId":"...", "ClientSecret":"...", "RefreshToken":"..."}]
          ACCOUNTS_JSON: ${{ secrets.ACCOUNTS_JSON }}
        run: |
          cd src
          dotnet run Program.cs refresh

      # Write the refresh log back to the repository
      - name: Write refresh.log
        if: success()
        shell: bash
        run: |        
          set -e
          TS="$(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          echo "Last refresh token succeeded at ${TS}" > refresh.log
          echo "Wrote refresh.log with timestamp: ${TS}"
          
          # Configure git user for commit
          git config --global user.name  "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
          # Stage the file
          git add refresh.log
          
          # Check if there's anything to commit
          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi
          
          # Commit the change locally first
          COMMIT_MSG="refresh log updated at ${TS}"
          git commit -m "chore: ${COMMIT_MSG}"
          echo "Committed refresh.log locally"
          
          # Pull with rebase to incorporate any remote changes
          # This works now because the local change is already committed
          git pull --rebase origin ${{ github.ref_name }} || {
            echo "Rebase conflict detected, attempting merge strategy"
            git rebase --abort
            git pull --no-rebase origin ${{ github.ref_name }}
          }
